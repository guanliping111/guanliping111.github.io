(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{420:function(t,s,a){"use strict";a.r(s);var e=a(30),v=Object(e.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h3",{attrs:{id:"_1-let、const使用场景"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-let、const使用场景"}},[t._v("#")]),t._v(" 1. let、const使用场景:")]),t._v(" "),a("ol",[a("li",[a("code",[t._v("let")]),t._v("使用场景：变量，用以替代"),a("code",[t._v("var")]),t._v(","),a("code",[t._v("for")]),t._v("循环的计数器，")]),t._v(" "),a("li",[a("code",[t._v("const")]),t._v("使用场景：常量、声明匿名函数、箭头函数的时候。")]),t._v(" "),a("li",[t._v("在代码块内，使用"),a("code",[t._v("let")]),t._v("命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”")])]),t._v(" "),a("h4",{attrs:{id:"let命令"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#let命令"}},[t._v("#")]),t._v(" let命令")]),t._v(" "),a("ul",[a("li",[a("h5",{attrs:{id:"特点-const-也一样"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#特点-const-也一样"}},[t._v("#")]),t._v(" 特点("),a("code",[t._v("const")]),t._v(" 也一样)")])])]),t._v(" "),a("ol",[a("li",[a("p",[t._v("不存在变量提升")])]),t._v(" "),a("li",[a("p",[t._v("暂时性死区")])]),t._v(" "),a("li",[a("p",[t._v("不可重复声明")])]),t._v(" "),a("li",[a("p",[t._v("块级作用域")])])]),t._v(" "),a("ul",[a("li",[a("h5",{attrs:{id:"let声明的变量只在它所在的代码块有效。"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#let声明的变量只在它所在的代码块有效。"}},[t._v("#")]),t._v(" "),a("code",[t._v("let")]),t._v("声明的变量只在它所在的代码块有效。")])]),t._v(" "),a("li",[a("h5",{attrs:{id:"不存在变量提升"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#不存在变量提升"}},[t._v("#")]),t._v(" 不存在变量提升")])])]),t._v(" "),a("p",[a("code",[t._v("var")]),t._v("命令会发生“变量提升”现象，即变量可以在声明之前使用，值为"),a("code",[t._v("undefined")]),t._v("。")]),t._v(" "),a("p",[a("code",[t._v("let")]),t._v("命令改变了语法行为，它所声明的变量一定要在声明后使用，否则报错。")]),t._v(" "),a("div",{staticClass:"language-javascript line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-javascript"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// var 的情况")]),t._v("\nconsole"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("foo"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 输出undefined")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" foo "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// let 的情况")]),t._v("\nconsole"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("bar"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 报错ReferenceError")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" bar "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br"),a("span",{staticClass:"line-number"},[t._v("5")]),a("br"),a("span",{staticClass:"line-number"},[t._v("6")]),a("br"),a("span",{staticClass:"line-number"},[t._v("7")]),a("br")])]),a("ul",[a("li",[a("h5",{attrs:{id:"暂时性死区"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#暂时性死区"}},[t._v("#")]),t._v(" 暂时性死区")])])]),t._v(" "),a("p",[t._v("只要块级作用域内存在"),a("code",[t._v("let")]),t._v("命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。")]),t._v(" "),a("p",[t._v("ES6A规定，"),a("code",[t._v("let")]),t._v(" 和"),a("code",[t._v("const")]),t._v(" 在区块内声明的变量，从一开始就形成了封闭的作用域。只要在声明之前使用，就会报错。")]),t._v(" "),a("p",[t._v("在代码块内，使用"),a("code",[t._v("let")]),t._v("命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”")]),t._v(" "),a("ul",[a("li",[a("h5",{attrs:{id:"不允许重复声明"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#不允许重复声明"}},[t._v("#")]),t._v(" 不允许重复声明")])])]),t._v(" "),a("p",[a("code",[t._v("let")]),t._v("不允许在相同作用域内，重复声明同一个变量。")]),t._v(" "),a("ul",[a("li",[a("h5",{attrs:{id:"块级作用域"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#块级作用域"}},[t._v("#")]),t._v(" 块级作用域")])])]),t._v(" "),a("ol",[a("li",[t._v("为什么需要块级作用域？")])]),t._v(" "),a("p",[t._v("ES5 只有全局作用域和函数作用域，没有块级作用域，这带来很多不合理的场景。")]),t._v(" "),a("ol",{attrs:{start:"2"}},[a("li",[t._v("ES6的块级作用域")])]),t._v(" "),a("p",[a("code",[t._v("let")]),t._v("实际上为 JavaScript 新增了块级作用域。")]),t._v(" "),a("p",[t._v("ES5 规定，函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域声明。")]),t._v(" "),a("p",[t._v("ES6 引入了块级作用域，明确允许在块级作用域之中声明函数：")]),t._v(" "),a("ul",[a("li",[t._v("允许在块级作用域内声明函数。")]),t._v(" "),a("li",[t._v("函数声明类似于"),a("code",[t._v("var")]),t._v("，即会提升到全局作用域或函数作用域的头部。")]),t._v(" "),a("li",[t._v("同时，函数声明还会提升到所在的块级作用域的头部。")])]),t._v(" "),a("h4",{attrs:{id:"const命令"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#const命令"}},[t._v("#")]),t._v(" const命令")]),t._v(" "),a("p",[a("code",[t._v("const")]),t._v("声明一个只读的常量。一旦声明，常量的值就不能改变，就必须立即初始化，不能留到以后赋值。")]),t._v(" "),a("p",[a("code",[t._v("const")]),t._v("命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。")]),t._v(" "),a("p",[a("code",[t._v("const")]),t._v("声明的常量，也与"),a("code",[t._v("let")]),t._v("一样不可重复声明。")]),t._v(" "),a("h3",{attrs:{id:"_2-var-const-let-的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-var-const-let-的区别"}},[t._v("#")]),t._v(" 2. var const let 的区别")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("var 和 let 用以声明变量，const 用于声明只读的常量；")])]),t._v(" "),a("li",[a("p",[t._v("var是函数作用域，let是块级作用域。比如在for循环中，")]),t._v(" "),a("p",[t._v("使用var定义初始变量，则在for的外层也可以使用这个变量")]),t._v(" "),a("p",[t._v("使用let定义初始变量，则只能在for产生的块级作用域中使用这个变量。")])]),t._v(" "),a("li",[a("p",[t._v("let 和 const 不存在像 var 那样的 "),a("a",{attrs:{href:"https://www.jianshu.com/p/d4b88723cd12",target:"_blank",rel:"noopener noreferrer"}},[t._v("“变量提升”"),a("OutboundLink")],1),t._v(" 现象，所以 var 定义变量可以先使用，后声明，而 let 和 const 只可先声明，后使用；")])]),t._v(" "),a("li",[a("p",[t._v("let 声明的变量存在暂时性死区，即只要块级作用域中存在 let，那么它所声明的变量就绑定了这个区域，不再受外部的影响。")])]),t._v(" "),a("li",[a("p",[t._v("const 声明的变量如果是基础类型，不能被修改。如果是引用类型，则可以修改引用类型的属性")])])]),t._v(" "),a("h3",{attrs:{id:"_3-var、let-和-const-区别的实现原理是什么？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-var、let-和-const-区别的实现原理是什么？"}},[t._v("#")]),t._v(" 3. var、let 和 const 区别的实现原理是什么？")]),t._v(" "),a("p",[t._v("https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/133")])])}),[],!1,null,null,null);s.default=v.exports}}]);